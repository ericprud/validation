PREFIX fhir: <http://hl7.org/fhir/> 
PREFIX fhirvs: <http://hl7.org/fhir/ValueSet/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
BASE <http://hl7.org/fhir/shape/>

IMPORT <id.shex>
IMPORT <uri.shex>
IMPORT <oid.shex>
IMPORT <url.shex>
IMPORT <Age.shex>
IMPORT <code.shex>
IMPORT <date.shex>
IMPORT <time.shex>
IMPORT <uuid.shex>
IMPORT <Meta.shex>
IMPORT <Count.shex>
IMPORT <Money.shex>
IMPORT <Range.shex>
IMPORT <Ratio.shex>
IMPORT <string.shex>
IMPORT <Coding.shex>
IMPORT <Period.shex>
IMPORT <Timing.shex>
IMPORT <Dosage.shex>
IMPORT <boolean.shex>
IMPORT <Element.shex>
IMPORT <decimal.shex>
IMPORT <instant.shex>
IMPORT <integer.shex>
IMPORT <Address.shex>
IMPORT <markdown.shex>
IMPORT <dateTime.shex>
IMPORT <Distance.shex>
IMPORT <Duration.shex>
IMPORT <Quantity.shex>
IMPORT <canonical.shex>
IMPORT <integer64.shex>
IMPORT <HumanName.shex>
IMPORT <Reference.shex>
IMPORT <Signature.shex>
IMPORT <Annotation.shex>
IMPORT <Attachment.shex>
IMPORT <Identifier.shex>
IMPORT <RatioRange.shex>
IMPORT <Expression.shex>
IMPORT <unsignedInt.shex>
IMPORT <positiveInt.shex>
IMPORT <SampledData.shex>
IMPORT <BackboneType.shex>
IMPORT <base64Binary.shex>
IMPORT <ContactPoint.shex>
IMPORT <UsageContext.shex>
IMPORT <Availability.shex>
IMPORT <ContactDetail.shex>
IMPORT <CodeableConcept.shex>
IMPORT <DataRequirement.shex>
IMPORT <RelatedArtifact.shex>
IMPORT <CodeableReference.shex>
IMPORT <TriggerDefinition.shex>
IMPORT <ParameterDefinition.shex>
IMPORT <ExtendedContactDetail.shex>

# Definition of an element in a resource or extension
<ElementDefinition> EXTENDS @<BackboneType> CLOSED {   

    a [fhir:ElementDefinition]?;
    fhir:nodeRole [fhir:treeRoot]?;

    fhir:path @<string>;                    # Path of the element in the 
                                            # hierarchy of elements 
    fhir:representation @<OneOrMore_code> AND
    	{fhir:v @fhirvs:property-representation}?;  # xmlAttr | xmlText | typeAttr | 
                                            # cdaText | xhtml 
    fhir:sliceName @<string>?;              # Name for this particular element 
                                            # (in a set of slices) 
    fhir:sliceIsConstraining @<boolean>?;   # If this slice definition 
                                            # constrains an inherited slice 
                                            # definition (or not) 
    fhir:label @<string>?;                  # Name for element to display with 
                                            # or prompt for element 
    fhir:code @<OneOrMore_Coding>?;         # Corresponding codes in 
                                            # terminologies 
    fhir:slicing @<Element>?;               # This element is sliced - slices 
                                            # follow 
    fhir:short @<string>?;                  # Concise definition for 
                                            # space-constrained presentation 
    fhir:definition @<markdown>?;           # Full formal definition as 
                                            # narrative text 
    fhir:comment @<markdown>?;              # Comments about the use of this 
                                            # element 
    fhir:requirements @<markdown>?;         # Why this resource has been created
    fhir:alias @<OneOrMore_string>?;        # Other names
    fhir:min @<unsignedInt>?;               # Minimum Cardinality
    fhir:max @<string>?;                    # Maximum Cardinality (a number or *)
    fhir:base @<Element>?;                  # Base definition information for 
                                            # tools 
    fhir:contentReference @<uri>?;          # Reference to definition of content 
                                            # for the element 
    fhir:type @<OneOrMore_Element>?;        # Data type and Profile for this 
                                            # element 
    fhir:defaultValue @<base64Binary>  OR 
    			@<boolean>  OR 
    			@<canonical>  OR 
    			@<code>  OR 
    			@<date>  OR 
    			@<dateTime>  OR 
    			@<decimal>  OR 
    			@<id>  OR 
    			@<instant>  OR 
    			@<integer>  OR 
    			@<integer64>  OR 
    			@<markdown>  OR 
    			@<oid>  OR 
    			@<positiveInt>  OR 
    			@<string>  OR 
    			@<time>  OR 
    			@<unsignedInt>  OR 
    			@<uri>  OR 
    			@<url>  OR 
    			@<uuid>  OR 
    			@<Address>  OR 
    			@<Age>  OR 
    			@<Annotation>  OR 
    			@<Attachment>  OR 
    			@<CodeableConcept>  OR 
    			@<CodeableReference>  OR 
    			@<Coding>  OR 
    			@<ContactPoint>  OR 
    			@<Count>  OR 
    			@<Distance>  OR 
    			@<Duration>  OR 
    			@<HumanName>  OR 
    			@<Identifier>  OR 
    			@<Money>  OR 
    			@<Period>  OR 
    			@<Quantity>  OR 
    			@<Range>  OR 
    			@<Ratio>  OR 
    			@<RatioRange>  OR 
    			@<Reference>  OR 
    			@<SampledData>  OR 
    			@<Signature>  OR 
    			@<Timing>  OR 
    			@<ContactDetail>  OR 
    			@<DataRequirement>  OR 
    			@<Expression>  OR 
    			@<ParameterDefinition>  OR 
    			@<RelatedArtifact>  OR 
    			@<TriggerDefinition>  OR 
    			@<UsageContext>  OR 
    			@<Availability>  OR 
    			@<ExtendedContactDetail>  OR 
    			@<Dosage>  OR 
    			@<Meta>  ?;  # Specified value if missing from 
                                            # instance 
    fhir:meaningWhenMissing @<markdown>?;   # Implicit meaning when this element 
                                            # is missing 
    fhir:orderMeaning @<string>?;           # What the order of the elements 
                                            # means 
    fhir:fixed @<base64Binary>  OR 
    			@<boolean>  OR 
    			@<canonical>  OR 
    			@<code>  OR 
    			@<date>  OR 
    			@<dateTime>  OR 
    			@<decimal>  OR 
    			@<id>  OR 
    			@<instant>  OR 
    			@<integer>  OR 
    			@<integer64>  OR 
    			@<markdown>  OR 
    			@<oid>  OR 
    			@<positiveInt>  OR 
    			@<string>  OR 
    			@<time>  OR 
    			@<unsignedInt>  OR 
    			@<uri>  OR 
    			@<url>  OR 
    			@<uuid>  OR 
    			@<Address>  OR 
    			@<Age>  OR 
    			@<Annotation>  OR 
    			@<Attachment>  OR 
    			@<CodeableConcept>  OR 
    			@<CodeableReference>  OR 
    			@<Coding>  OR 
    			@<ContactPoint>  OR 
    			@<Count>  OR 
    			@<Distance>  OR 
    			@<Duration>  OR 
    			@<HumanName>  OR 
    			@<Identifier>  OR 
    			@<Money>  OR 
    			@<Period>  OR 
    			@<Quantity>  OR 
    			@<Range>  OR 
    			@<Ratio>  OR 
    			@<RatioRange>  OR 
    			@<Reference>  OR 
    			@<SampledData>  OR 
    			@<Signature>  OR 
    			@<Timing>  OR 
    			@<ContactDetail>  OR 
    			@<DataRequirement>  OR 
    			@<Expression>  OR 
    			@<ParameterDefinition>  OR 
    			@<RelatedArtifact>  OR 
    			@<TriggerDefinition>  OR 
    			@<UsageContext>  OR 
    			@<Availability>  OR 
    			@<ExtendedContactDetail>  OR 
    			@<Dosage>  OR 
    			@<Meta>  ?;  # Value must be exactly this
    fhir:pattern @<base64Binary>  OR 
    			@<boolean>  OR 
    			@<canonical>  OR 
    			@<code>  OR 
    			@<date>  OR 
    			@<dateTime>  OR 
    			@<decimal>  OR 
    			@<id>  OR 
    			@<instant>  OR 
    			@<integer>  OR 
    			@<integer64>  OR 
    			@<markdown>  OR 
    			@<oid>  OR 
    			@<positiveInt>  OR 
    			@<string>  OR 
    			@<time>  OR 
    			@<unsignedInt>  OR 
    			@<uri>  OR 
    			@<url>  OR 
    			@<uuid>  OR 
    			@<Address>  OR 
    			@<Age>  OR 
    			@<Annotation>  OR 
    			@<Attachment>  OR 
    			@<CodeableConcept>  OR 
    			@<CodeableReference>  OR 
    			@<Coding>  OR 
    			@<ContactPoint>  OR 
    			@<Count>  OR 
    			@<Distance>  OR 
    			@<Duration>  OR 
    			@<HumanName>  OR 
    			@<Identifier>  OR 
    			@<Money>  OR 
    			@<Period>  OR 
    			@<Quantity>  OR 
    			@<Range>  OR 
    			@<Ratio>  OR 
    			@<RatioRange>  OR 
    			@<Reference>  OR 
    			@<SampledData>  OR 
    			@<Signature>  OR 
    			@<Timing>  OR 
    			@<ContactDetail>  OR 
    			@<DataRequirement>  OR 
    			@<Expression>  OR 
    			@<ParameterDefinition>  OR 
    			@<RelatedArtifact>  OR 
    			@<TriggerDefinition>  OR 
    			@<UsageContext>  OR 
    			@<Availability>  OR 
    			@<ExtendedContactDetail>  OR 
    			@<Dosage>  OR 
    			@<Meta>  ?;  # Value must have at least these 
                                            # property values 
    fhir:example @<OneOrMore_Element>?;     # Example value (as defined for type)
    fhir:minValue @<date>  OR 
    			@<dateTime>  OR 
    			@<instant>  OR 
    			@<time>  OR 
    			@<decimal>  OR 
    			@<integer>  OR 
    			@<integer64>  OR 
    			@<positiveInt>  OR 
    			@<unsignedInt>  OR 
    			@<Quantity>  ?;  # Minimum Allowed Value (for some 
                                            # types) 
    fhir:maxValue @<date>  OR 
    			@<dateTime>  OR 
    			@<instant>  OR 
    			@<time>  OR 
    			@<decimal>  OR 
    			@<integer>  OR 
    			@<integer64>  OR 
    			@<positiveInt>  OR 
    			@<unsignedInt>  OR 
    			@<Quantity>  ?;  # Maximum Allowed Value (for some 
                                            # types) 
    fhir:maxLength @<integer>?;             # Max length for string type data
    fhir:condition @<OneOrMore_id>?;        # Reference to invariant about 
                                            # presence 
    fhir:constraint @<OneOrMore_Element>?;  # Condition that must evaluate to 
                                            # true 
    fhir:mustHaveValue @<boolean>?;         # For primitives, that a value must 
                                            # be present - not replaced by an 
                                            # extension 
    fhir:valueAlternatives @<OneOrMore_canonical>?;  # Extensions that are allowed to 
                                            # replace a primitive value 
    fhir:mustSupport @<boolean>?;           # If the element must be supported 
                                            # (discouraged - see obligations) 
    fhir:obligation @<OneOrMore_Element>?;  # Documents obligations for 
                                            # applications making use of this 
                                            # element 
    fhir:isModifier @<boolean>?;            # If this modifies the meaning of 
                                            # other elements 
    fhir:isModifierReason @<string>?;       # Reason that this element is marked 
                                            # as a modifier 
    fhir:isSummary @<boolean>?;             # Include when _summary = true?
    fhir:binding @<Element>?;               # ValueSet details if this is coded
    fhir:mapping @<OneOrMore_Element>?;     # Map element to another set of 
                                            # definitions 
} AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-3
# Human readable:Max SHALL be a number or "*"
#
# Constraint: empty() or ($this = '*') or (toInteger() >= 0)
# ShEx:
#
# NOT {  {fhir:v .} }  OR ({ fhir:$this { fhir:v ['*'] }  }) OR (   toInteger  (  ) { fhir:v MinInclusive 0 } )
{}

) AND (

# Constraint UniqueKey:eld-19
# Human readable:Element names cannot include some special characters with a max of 64 characters,

# Constraint: path.matches('^[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\.[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\[x\\])?(\\:[^\\s\\.]+)?)*$')
# ShEx:

{fhir:path { fhir:v /'^[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\.[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\[x\])?(\:[^\s\.]+)?)*$'/ } }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: iif
# Unmapped construct found: LessOrEqual
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-2
# Human readable:Min <= Max
#
# Constraint: min.empty() or max.empty() or (max = '*') or iif(max != '*', min <= max.toInteger())
# ShEx:
#
# NOT { fhir:min {fhir:v .} }  OR  NOT { fhir:max {fhir:v .} }  OR ({ fhir:max { fhir:v ['*'] }  }) OR   iif  ({ fhir:max [fhir:v  . -'*']  }, { fhir:min  LessOrEqual     toInteger  ( fhir:max ) })
{}

) AND (

# Constraint UniqueKey:eld-5
# Human readable:if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding

# Constraint: contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())
# ShEx:

 NOT { fhir:contentReference {fhir:v .} }  OR ( NOT { fhir:type {fhir:v .} }  AND  NOT { fhir:defaultValue {fhir:v .} }  AND  NOT { fhir:fixed {fhir:v .} }  AND  NOT { fhir:pattern {fhir:v .} }  AND  NOT { fhir:example {fhir:v .} }  AND  NOT { fhir:minValue {fhir:v .} }  AND  NOT { fhir:maxValue {fhir:v .} }  AND  NOT { fhir:maxLength {fhir:v .} }  AND  NOT { fhir:binding {fhir:v .} } )

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-7
# Human readable:Pattern may only be specified if there is one type
#
# Constraint: pattern.empty() or (type.count() <= 1)
# ShEx:
#
# NOT { fhir:pattern {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-6
# Human readable:Fixed value may only be specified if there is one type
#
# Constraint: fixed.empty() or (type.count()  <= 1)
# ShEx:
#
# NOT { fhir:fixed {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-22
# Human readable:sliceIsConstraining can only appear if slicename is present
#
# Constraint: sliceIsConstraining.exists() implies sliceName.exists()
# ShEx:
#
#{fhir:sliceIsConstraining .  Implies  {fhir:sliceName .}}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: select
# # Constraint UniqueKey:eld-11
# Human readable:Binding can only be present for coded elements, string, and uri if using FHIR-defined types
#
# Constraint: binding.empty() or type.code.empty() or type.code.contains(":") or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri') or (code = 'Duration')).exists()
# ShEx:
#
# NOT { fhir:binding {fhir:v .} }  OR  NOT { fhir:type.code {fhir:v .} }  OR {fhir:type.code { fhir:v [':'] }  OR {fhir:type.  select  (code { fhir:v ['code'] }  OR code { fhir:v ['Coding'] }  OR code { fhir:v ['CodeableConcept'] }  OR code { fhir:v ['Quantity'] }  OR code { fhir:v ['string'] }  OR code { fhir:v ['uri'] }  OR code { fhir:v ['Duration'] } ) .}}
{}

) AND (

# Constraint UniqueKey:eld-8
# Human readable:Pattern and fixed are mutually exclusive

# Constraint: pattern.empty() or fixed.empty()
# ShEx:

 NOT { fhir:pattern {fhir:v .} }  OR  NOT { fhir:fixed {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: where
# # Constraint UniqueKey:eld-25
# Human readable:Order has no meaning (and cannot be asserted to have meaning), so enforcing rules on order is improper
#
# Constraint: orderMeaning.empty() implies slicing.where(rules='openAtEnd' or ordered).exists().not()
# ShEx:
#
# NOT { fhir:orderMeaning {fhir:v .} }   Implies   NOT { fhir:slicing.  where  (rules { fhir:v ['openAtEnd'] }  OR ordered) . }
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-14
# Human readable:Constraints must be unique by key
#
# Constraint: constraint.select(key).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:constraint.  select  (key) )
{}

) AND (

# Constraint UniqueKey:eld-24
# Human readable:pattern[x] should be used rather than fixed[x]

# Constraint: fixed.exists().not()
# ShEx:

 NOT { fhir:fixed . }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-13
# Human readable:Types must be unique by code
#
# Constraint: type.select(code).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:type.  select  (code) )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-27
# Human readable:Mappings SHOULD be unique by key
#
# Constraint: mapping.select(identity).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:mapping.  select  (identity) )
{}

) AND (

# Constraint UniqueKey:eld-16
# Human readable:sliceName must be composed of proper tokens separated by "/"

# Constraint: sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\/\\-_\\[\\]\\@]+$')
# ShEx:

 NOT { fhir:sliceName {fhir:v .} }  OR {fhir:sliceName { fhir:v /'^[a-zA-Z0-9\/\-_\[\]\@]+$'/ } }

) AND (

# Constraint UniqueKey:eld-15
# Human readable:default value and meaningWhenMissing are mutually exclusive

# Constraint: defaultValue.empty() or meaningWhenMissing.empty()
# ShEx:

 NOT { fhir:defaultValue {fhir:v .} }  OR  NOT { fhir:meaningWhenMissing {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-18
# Human readable:Must have a modifier reason if isModifier = true
#
# Constraint: (isModifier.exists() and isModifier) implies isModifierReason.exists()
# ShEx:
#
#({fhir:isModifier . AND { fhir:isModifier }})  Implies  {fhir:isModifierReason .}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-28
# Human readable:Can't have valueAlternatives if mustHaveValue is true
#
# Constraint: mustHaveValue.value implies valueAlternatives.empty()
# ShEx:
#
#{fhir:mustHaveValue.value  Implies   NOT { fhir:valueAlternatives {fhir:v .} } }
{}

) AND (

# Constraint UniqueKey:eld-20
# Human readable:Element names should be simple alphanumerics with a max of 64 characters or code generation tools may be broken

# Constraint: path.matches('^[A-Za-z][A-Za-z0-9]{0,63}(\\.[a-z][A-Za-z0-9]{0,63}(\\[x])?)*$')
# ShEx:

{fhir:path { fhir:v /'^[A-Za-z][A-Za-z0-9]{0,63}(\.[a-z][A-Za-z0-9]{0,63}(\[x])?)*$'/ } }

) AND (

# Constraint UniqueKey:eld-4
# Human readable:Aggregation may only be specified if one of the allowed types for the element is a reference

# Constraint: aggregation.empty() or (code = 'Reference') or (code = 'canonical') or (code = 'CodeableReference')
# ShEx:

 NOT { fhir:aggregation {fhir:v .} }  OR ({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })

) AND (

# Constraint UniqueKey:eld-17
# Human readable:targetProfile is only allowed if the type is Reference or canonical

# Constraint: (code='Reference' or code = 'canonical' or code = 'CodeableReference') or targetProfile.empty()
# ShEx:

(({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })) OR  NOT { fhir:targetProfile {fhir:v .} } 

) AND (

# Constraint UniqueKey:eld-21
# Human readable:Constraints should have an expression or else validators will not be able to enforce them

# Constraint: expression.exists()
# ShEx:

{fhir:expression .}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-26
# Human readable:Errors cannot be suppressed
#
# Constraint: (severity = 'error') implies suppress.empty()
# ShEx:
#
#({ fhir:severity { fhir:v ['error'] }  })  Implies   NOT { fhir:suppress {fhir:v .} } 
{}

) AND (

# Constraint UniqueKey:eld-23
# Human readable:binding SHALL have either description or valueSet

# Constraint: description.exists() or valueSet.exists()
# ShEx:

{fhir:description . OR {fhir:valueSet .}}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# # Constraint UniqueKey:eld-12
# Human readable:ValueSet SHALL start with http:// or https:// or urn: or #
#
# Constraint: valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:') or valueSet.startsWith('#'))
# ShEx:
#
#{fhir:valueSet .  Implies  ({fhir:valueSet.  startsWith  ('http:') OR {fhir:valueSet.  startsWith  ('https') OR {fhir:valueSet.  startsWith  ('urn:') OR {fhir:valueSet.  startsWith  ('#')}}}})}
{}

)
 

# Base definition information for tools
<ElementDefinition.base> EXTENDS @<Element> CLOSED {   
    fhir:path @<string>;                    # Path that identifies the base 
                                            # element 
    fhir:min @<unsignedInt>;                # Min cardinality of the base element
    fhir:max @<string>;                     # Max cardinality of the base element
}  

# Data type and Profile for this element
<ElementDefinition.type> EXTENDS @<Element> CLOSED {   
    fhir:code @<uri>;                       # Data type or Resource (reference 
                                            # to definition) 
    fhir:profile @<OneOrMore_canonical>?;   # Profiles (StructureDefinition or 
                                            # IG) - one must apply 
    fhir:targetProfile @<OneOrMore_canonical>?;  # Profile (StructureDefinition or 
                                            # IG) on the Reference/canonical 
                                            # target - one must apply 
    fhir:aggregation @<OneOrMore_code> AND
    	{fhir:v @fhirvs:resource-aggregation-mode}?;  # contained | referenced | bundled - 
                                            # how aggregated 
    fhir:versioning @<code> AND
    	{fhir:v @fhirvs:reference-version-rules}?;  # either | independent | specific
} AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-3
# Human readable:Max SHALL be a number or "*"
#
# Constraint: empty() or ($this = '*') or (toInteger() >= 0)
# ShEx:
#
# NOT {  {fhir:v .} }  OR ({ fhir:$this { fhir:v ['*'] }  }) OR (   toInteger  (  ) { fhir:v MinInclusive 0 } )
{}

) AND (

# Constraint UniqueKey:eld-19
# Human readable:Element names cannot include some special characters with a max of 64 characters,

# Constraint: path.matches('^[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\.[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\[x\\])?(\\:[^\\s\\.]+)?)*$')
# ShEx:

{fhir:path { fhir:v /'^[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\.[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\[x\])?(\:[^\s\.]+)?)*$'/ } }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: iif
# Unmapped construct found: LessOrEqual
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-2
# Human readable:Min <= Max
#
# Constraint: min.empty() or max.empty() or (max = '*') or iif(max != '*', min <= max.toInteger())
# ShEx:
#
# NOT { fhir:min {fhir:v .} }  OR  NOT { fhir:max {fhir:v .} }  OR ({ fhir:max { fhir:v ['*'] }  }) OR   iif  ({ fhir:max [fhir:v  . -'*']  }, { fhir:min  LessOrEqual     toInteger  ( fhir:max ) })
{}

) AND (

# Constraint UniqueKey:eld-5
# Human readable:if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding

# Constraint: contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())
# ShEx:

 NOT { fhir:contentReference {fhir:v .} }  OR ( NOT { fhir:type {fhir:v .} }  AND  NOT { fhir:defaultValue {fhir:v .} }  AND  NOT { fhir:fixed {fhir:v .} }  AND  NOT { fhir:pattern {fhir:v .} }  AND  NOT { fhir:example {fhir:v .} }  AND  NOT { fhir:minValue {fhir:v .} }  AND  NOT { fhir:maxValue {fhir:v .} }  AND  NOT { fhir:maxLength {fhir:v .} }  AND  NOT { fhir:binding {fhir:v .} } )

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-7
# Human readable:Pattern may only be specified if there is one type
#
# Constraint: pattern.empty() or (type.count() <= 1)
# ShEx:
#
# NOT { fhir:pattern {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-6
# Human readable:Fixed value may only be specified if there is one type
#
# Constraint: fixed.empty() or (type.count()  <= 1)
# ShEx:
#
# NOT { fhir:fixed {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-22
# Human readable:sliceIsConstraining can only appear if slicename is present
#
# Constraint: sliceIsConstraining.exists() implies sliceName.exists()
# ShEx:
#
#{fhir:sliceIsConstraining .  Implies  {fhir:sliceName .}}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: select
# # Constraint UniqueKey:eld-11
# Human readable:Binding can only be present for coded elements, string, and uri if using FHIR-defined types
#
# Constraint: binding.empty() or type.code.empty() or type.code.contains(":") or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri') or (code = 'Duration')).exists()
# ShEx:
#
# NOT { fhir:binding {fhir:v .} }  OR  NOT { fhir:type.code {fhir:v .} }  OR {fhir:type.code { fhir:v [':'] }  OR {fhir:type.  select  (code { fhir:v ['code'] }  OR code { fhir:v ['Coding'] }  OR code { fhir:v ['CodeableConcept'] }  OR code { fhir:v ['Quantity'] }  OR code { fhir:v ['string'] }  OR code { fhir:v ['uri'] }  OR code { fhir:v ['Duration'] } ) .}}
{}

) AND (

# Constraint UniqueKey:eld-8
# Human readable:Pattern and fixed are mutually exclusive

# Constraint: pattern.empty() or fixed.empty()
# ShEx:

 NOT { fhir:pattern {fhir:v .} }  OR  NOT { fhir:fixed {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: where
# # Constraint UniqueKey:eld-25
# Human readable:Order has no meaning (and cannot be asserted to have meaning), so enforcing rules on order is improper
#
# Constraint: orderMeaning.empty() implies slicing.where(rules='openAtEnd' or ordered).exists().not()
# ShEx:
#
# NOT { fhir:orderMeaning {fhir:v .} }   Implies   NOT { fhir:slicing.  where  (rules { fhir:v ['openAtEnd'] }  OR ordered) . }
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-14
# Human readable:Constraints must be unique by key
#
# Constraint: constraint.select(key).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:constraint.  select  (key) )
{}

) AND (

# Constraint UniqueKey:eld-24
# Human readable:pattern[x] should be used rather than fixed[x]

# Constraint: fixed.exists().not()
# ShEx:

 NOT { fhir:fixed . }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-13
# Human readable:Types must be unique by code
#
# Constraint: type.select(code).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:type.  select  (code) )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-27
# Human readable:Mappings SHOULD be unique by key
#
# Constraint: mapping.select(identity).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:mapping.  select  (identity) )
{}

) AND (

# Constraint UniqueKey:eld-16
# Human readable:sliceName must be composed of proper tokens separated by "/"

# Constraint: sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\/\\-_\\[\\]\\@]+$')
# ShEx:

 NOT { fhir:sliceName {fhir:v .} }  OR {fhir:sliceName { fhir:v /'^[a-zA-Z0-9\/\-_\[\]\@]+$'/ } }

) AND (

# Constraint UniqueKey:eld-15
# Human readable:default value and meaningWhenMissing are mutually exclusive

# Constraint: defaultValue.empty() or meaningWhenMissing.empty()
# ShEx:

 NOT { fhir:defaultValue {fhir:v .} }  OR  NOT { fhir:meaningWhenMissing {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-18
# Human readable:Must have a modifier reason if isModifier = true
#
# Constraint: (isModifier.exists() and isModifier) implies isModifierReason.exists()
# ShEx:
#
#({fhir:isModifier . AND { fhir:isModifier }})  Implies  {fhir:isModifierReason .}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-28
# Human readable:Can't have valueAlternatives if mustHaveValue is true
#
# Constraint: mustHaveValue.value implies valueAlternatives.empty()
# ShEx:
#
#{fhir:mustHaveValue.value  Implies   NOT { fhir:valueAlternatives {fhir:v .} } }
{}

) AND (

# Constraint UniqueKey:eld-20
# Human readable:Element names should be simple alphanumerics with a max of 64 characters or code generation tools may be broken

# Constraint: path.matches('^[A-Za-z][A-Za-z0-9]{0,63}(\\.[a-z][A-Za-z0-9]{0,63}(\\[x])?)*$')
# ShEx:

{fhir:path { fhir:v /'^[A-Za-z][A-Za-z0-9]{0,63}(\.[a-z][A-Za-z0-9]{0,63}(\[x])?)*$'/ } }

) AND (

# Constraint UniqueKey:eld-4
# Human readable:Aggregation may only be specified if one of the allowed types for the element is a reference

# Constraint: aggregation.empty() or (code = 'Reference') or (code = 'canonical') or (code = 'CodeableReference')
# ShEx:

 NOT { fhir:aggregation {fhir:v .} }  OR ({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })

) AND (

# Constraint UniqueKey:eld-17
# Human readable:targetProfile is only allowed if the type is Reference or canonical

# Constraint: (code='Reference' or code = 'canonical' or code = 'CodeableReference') or targetProfile.empty()
# ShEx:

(({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })) OR  NOT { fhir:targetProfile {fhir:v .} } 

) AND (

# Constraint UniqueKey:eld-21
# Human readable:Constraints should have an expression or else validators will not be able to enforce them

# Constraint: expression.exists()
# ShEx:

{fhir:expression .}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-26
# Human readable:Errors cannot be suppressed
#
# Constraint: (severity = 'error') implies suppress.empty()
# ShEx:
#
#({ fhir:severity { fhir:v ['error'] }  })  Implies   NOT { fhir:suppress {fhir:v .} } 
{}

) AND (

# Constraint UniqueKey:eld-23
# Human readable:binding SHALL have either description or valueSet

# Constraint: description.exists() or valueSet.exists()
# ShEx:

{fhir:description . OR {fhir:valueSet .}}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# # Constraint UniqueKey:eld-12
# Human readable:ValueSet SHALL start with http:// or https:// or urn: or #
#
# Constraint: valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:') or valueSet.startsWith('#'))
# ShEx:
#
#{fhir:valueSet .  Implies  ({fhir:valueSet.  startsWith  ('http:') OR {fhir:valueSet.  startsWith  ('https') OR {fhir:valueSet.  startsWith  ('urn:') OR {fhir:valueSet.  startsWith  ('#')}}}})}
{}

)
 

# Condition that must evaluate to true
<ElementDefinition.constraint> EXTENDS @<Element> CLOSED {   
    fhir:key @<id>;                         # Target of 'condition' reference 
                                            # above 
    fhir:requirements @<markdown>?;         # Why this constraint is necessary 
                                            # or appropriate 
    fhir:severity @<code> AND
    	{fhir:v @fhirvs:constraint-severity};  # error | warning
    fhir:suppress @<boolean>?;              # Suppress warning or hint in profile
    fhir:human @<string>;                   # Human description of constraint
    fhir:expression @<string>?;             # FHIRPath expression of constraint
    fhir:source @<canonical>?;              # Reference to original source of 
                                            # constraint 
} AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-3
# Human readable:Max SHALL be a number or "*"
#
# Constraint: empty() or ($this = '*') or (toInteger() >= 0)
# ShEx:
#
# NOT {  {fhir:v .} }  OR ({ fhir:$this { fhir:v ['*'] }  }) OR (   toInteger  (  ) { fhir:v MinInclusive 0 } )
{}

) AND (

# Constraint UniqueKey:eld-19
# Human readable:Element names cannot include some special characters with a max of 64 characters,

# Constraint: path.matches('^[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\.[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\[x\\])?(\\:[^\\s\\.]+)?)*$')
# ShEx:

{fhir:path { fhir:v /'^[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\.[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\[x\])?(\:[^\s\.]+)?)*$'/ } }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: iif
# Unmapped construct found: LessOrEqual
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-2
# Human readable:Min <= Max
#
# Constraint: min.empty() or max.empty() or (max = '*') or iif(max != '*', min <= max.toInteger())
# ShEx:
#
# NOT { fhir:min {fhir:v .} }  OR  NOT { fhir:max {fhir:v .} }  OR ({ fhir:max { fhir:v ['*'] }  }) OR   iif  ({ fhir:max [fhir:v  . -'*']  }, { fhir:min  LessOrEqual     toInteger  ( fhir:max ) })
{}

) AND (

# Constraint UniqueKey:eld-5
# Human readable:if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding

# Constraint: contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())
# ShEx:

 NOT { fhir:contentReference {fhir:v .} }  OR ( NOT { fhir:type {fhir:v .} }  AND  NOT { fhir:defaultValue {fhir:v .} }  AND  NOT { fhir:fixed {fhir:v .} }  AND  NOT { fhir:pattern {fhir:v .} }  AND  NOT { fhir:example {fhir:v .} }  AND  NOT { fhir:minValue {fhir:v .} }  AND  NOT { fhir:maxValue {fhir:v .} }  AND  NOT { fhir:maxLength {fhir:v .} }  AND  NOT { fhir:binding {fhir:v .} } )

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-7
# Human readable:Pattern may only be specified if there is one type
#
# Constraint: pattern.empty() or (type.count() <= 1)
# ShEx:
#
# NOT { fhir:pattern {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-6
# Human readable:Fixed value may only be specified if there is one type
#
# Constraint: fixed.empty() or (type.count()  <= 1)
# ShEx:
#
# NOT { fhir:fixed {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-22
# Human readable:sliceIsConstraining can only appear if slicename is present
#
# Constraint: sliceIsConstraining.exists() implies sliceName.exists()
# ShEx:
#
#{fhir:sliceIsConstraining .  Implies  {fhir:sliceName .}}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: select
# # Constraint UniqueKey:eld-11
# Human readable:Binding can only be present for coded elements, string, and uri if using FHIR-defined types
#
# Constraint: binding.empty() or type.code.empty() or type.code.contains(":") or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri') or (code = 'Duration')).exists()
# ShEx:
#
# NOT { fhir:binding {fhir:v .} }  OR  NOT { fhir:type.code {fhir:v .} }  OR {fhir:type.code { fhir:v [':'] }  OR {fhir:type.  select  (code { fhir:v ['code'] }  OR code { fhir:v ['Coding'] }  OR code { fhir:v ['CodeableConcept'] }  OR code { fhir:v ['Quantity'] }  OR code { fhir:v ['string'] }  OR code { fhir:v ['uri'] }  OR code { fhir:v ['Duration'] } ) .}}
{}

) AND (

# Constraint UniqueKey:eld-8
# Human readable:Pattern and fixed are mutually exclusive

# Constraint: pattern.empty() or fixed.empty()
# ShEx:

 NOT { fhir:pattern {fhir:v .} }  OR  NOT { fhir:fixed {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: where
# # Constraint UniqueKey:eld-25
# Human readable:Order has no meaning (and cannot be asserted to have meaning), so enforcing rules on order is improper
#
# Constraint: orderMeaning.empty() implies slicing.where(rules='openAtEnd' or ordered).exists().not()
# ShEx:
#
# NOT { fhir:orderMeaning {fhir:v .} }   Implies   NOT { fhir:slicing.  where  (rules { fhir:v ['openAtEnd'] }  OR ordered) . }
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-14
# Human readable:Constraints must be unique by key
#
# Constraint: constraint.select(key).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:constraint.  select  (key) )
{}

) AND (

# Constraint UniqueKey:eld-24
# Human readable:pattern[x] should be used rather than fixed[x]

# Constraint: fixed.exists().not()
# ShEx:

 NOT { fhir:fixed . }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-13
# Human readable:Types must be unique by code
#
# Constraint: type.select(code).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:type.  select  (code) )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-27
# Human readable:Mappings SHOULD be unique by key
#
# Constraint: mapping.select(identity).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:mapping.  select  (identity) )
{}

) AND (

# Constraint UniqueKey:eld-16
# Human readable:sliceName must be composed of proper tokens separated by "/"

# Constraint: sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\/\\-_\\[\\]\\@]+$')
# ShEx:

 NOT { fhir:sliceName {fhir:v .} }  OR {fhir:sliceName { fhir:v /'^[a-zA-Z0-9\/\-_\[\]\@]+$'/ } }

) AND (

# Constraint UniqueKey:eld-15
# Human readable:default value and meaningWhenMissing are mutually exclusive

# Constraint: defaultValue.empty() or meaningWhenMissing.empty()
# ShEx:

 NOT { fhir:defaultValue {fhir:v .} }  OR  NOT { fhir:meaningWhenMissing {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-18
# Human readable:Must have a modifier reason if isModifier = true
#
# Constraint: (isModifier.exists() and isModifier) implies isModifierReason.exists()
# ShEx:
#
#({fhir:isModifier . AND { fhir:isModifier }})  Implies  {fhir:isModifierReason .}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-28
# Human readable:Can't have valueAlternatives if mustHaveValue is true
#
# Constraint: mustHaveValue.value implies valueAlternatives.empty()
# ShEx:
#
#{fhir:mustHaveValue.value  Implies   NOT { fhir:valueAlternatives {fhir:v .} } }
{}

) AND (

# Constraint UniqueKey:eld-20
# Human readable:Element names should be simple alphanumerics with a max of 64 characters or code generation tools may be broken

# Constraint: path.matches('^[A-Za-z][A-Za-z0-9]{0,63}(\\.[a-z][A-Za-z0-9]{0,63}(\\[x])?)*$')
# ShEx:

{fhir:path { fhir:v /'^[A-Za-z][A-Za-z0-9]{0,63}(\.[a-z][A-Za-z0-9]{0,63}(\[x])?)*$'/ } }

) AND (

# Constraint UniqueKey:eld-4
# Human readable:Aggregation may only be specified if one of the allowed types for the element is a reference

# Constraint: aggregation.empty() or (code = 'Reference') or (code = 'canonical') or (code = 'CodeableReference')
# ShEx:

 NOT { fhir:aggregation {fhir:v .} }  OR ({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })

) AND (

# Constraint UniqueKey:eld-17
# Human readable:targetProfile is only allowed if the type is Reference or canonical

# Constraint: (code='Reference' or code = 'canonical' or code = 'CodeableReference') or targetProfile.empty()
# ShEx:

(({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })) OR  NOT { fhir:targetProfile {fhir:v .} } 

) AND (

# Constraint UniqueKey:eld-21
# Human readable:Constraints should have an expression or else validators will not be able to enforce them

# Constraint: expression.exists()
# ShEx:

{fhir:expression .}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-26
# Human readable:Errors cannot be suppressed
#
# Constraint: (severity = 'error') implies suppress.empty()
# ShEx:
#
#({ fhir:severity { fhir:v ['error'] }  })  Implies   NOT { fhir:suppress {fhir:v .} } 
{}

) AND (

# Constraint UniqueKey:eld-23
# Human readable:binding SHALL have either description or valueSet

# Constraint: description.exists() or valueSet.exists()
# ShEx:

{fhir:description . OR {fhir:valueSet .}}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# # Constraint UniqueKey:eld-12
# Human readable:ValueSet SHALL start with http:// or https:// or urn: or #
#
# Constraint: valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:') or valueSet.startsWith('#'))
# ShEx:
#
#{fhir:valueSet .  Implies  ({fhir:valueSet.  startsWith  ('http:') OR {fhir:valueSet.  startsWith  ('https') OR {fhir:valueSet.  startsWith  ('urn:') OR {fhir:valueSet.  startsWith  ('#')}}}})}
{}

)
 

# Documents obligations for applications making use of this element
<ElementDefinition.obligation> EXTENDS @<Element> CLOSED {   
    fhir:code @<Coding>;                    # Combination code describing the 
                                            # nature of the obligation 
    fhir:actor @<OneOrMore_canonical>?;     # Actor(s) this obligation applies 
                                            # to (all actors if none) 
    fhir:documentation @<markdown>?;        # Documentation of the purpose or 
                                            # application of the obligation 
    fhir:usage @<OneOrMore_UsageContext>?;  # Qualifies the usage - 
                                            # jurisdiction, gender, workflow 
                                            # status etc 
    fhir:filter @<string>?;                 # Limits obligation to some repeats 
                                            # by FHIRPath 
    fhir:filterDocumentation @<string>?;    # Ddescribes the intent of the 
                                            # filter (short) 
    fhir:process @<OneOrMore_uri>?;         # The obligation only applies when 
                                            # perfomring the indicated process 
}  

# ValueSet details if this is coded
<ElementDefinition.binding> EXTENDS @<Element> CLOSED {   
    fhir:strength @<code> AND
    	{fhir:v @fhirvs:binding-strength};  # required | extensible | preferred 
                                            # | example 
    fhir:description @<markdown>?;          # Intended use of codes in the bound 
                                            # value set 
    fhir:valueSet @<canonical>?;            # Source of value set
    fhir:additional @<OneOrMore_Element>?;  # Additional Bindings - more rules 
                                            # about the binding 
} AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-3
# Human readable:Max SHALL be a number or "*"
#
# Constraint: empty() or ($this = '*') or (toInteger() >= 0)
# ShEx:
#
# NOT {  {fhir:v .} }  OR ({ fhir:$this { fhir:v ['*'] }  }) OR (   toInteger  (  ) { fhir:v MinInclusive 0 } )
{}

) AND (

# Constraint UniqueKey:eld-19
# Human readable:Element names cannot include some special characters with a max of 64 characters,

# Constraint: path.matches('^[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\.[^\\s\\.,:;\\\'"\\/|?!@#$%&*()\\[\\]{}]{1,64}(\\[x\\])?(\\:[^\\s\\.]+)?)*$')
# ShEx:

{fhir:path { fhir:v /'^[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\.[^\s\.,:;\'"\/|?!@#$%&*()\[\]{}]{1,64}(\[x\])?(\:[^\s\.]+)?)*$'/ } }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: iif
# Unmapped construct found: LessOrEqual
# Unmapped construct found: toInteger
# # Constraint UniqueKey:eld-2
# Human readable:Min <= Max
#
# Constraint: min.empty() or max.empty() or (max = '*') or iif(max != '*', min <= max.toInteger())
# ShEx:
#
# NOT { fhir:min {fhir:v .} }  OR  NOT { fhir:max {fhir:v .} }  OR ({ fhir:max { fhir:v ['*'] }  }) OR   iif  ({ fhir:max [fhir:v  . -'*']  }, { fhir:min  LessOrEqual     toInteger  ( fhir:max ) })
{}

) AND (

# Constraint UniqueKey:eld-5
# Human readable:if the element definition has a contentReference, it cannot have type, defaultValue, fixed, pattern, example, minValue, maxValue, maxLength, or binding

# Constraint: contentReference.empty() or (type.empty() and defaultValue.empty() and fixed.empty() and pattern.empty() and example.empty() and minValue.empty() and maxValue.empty() and maxLength.empty() and binding.empty())
# ShEx:

 NOT { fhir:contentReference {fhir:v .} }  OR ( NOT { fhir:type {fhir:v .} }  AND  NOT { fhir:defaultValue {fhir:v .} }  AND  NOT { fhir:fixed {fhir:v .} }  AND  NOT { fhir:pattern {fhir:v .} }  AND  NOT { fhir:example {fhir:v .} }  AND  NOT { fhir:minValue {fhir:v .} }  AND  NOT { fhir:maxValue {fhir:v .} }  AND  NOT { fhir:maxLength {fhir:v .} }  AND  NOT { fhir:binding {fhir:v .} } )

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-7
# Human readable:Pattern may only be specified if there is one type
#
# Constraint: pattern.empty() or (type.count() <= 1)
# ShEx:
#
# NOT { fhir:pattern {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: count
# # Constraint UniqueKey:eld-6
# Human readable:Fixed value may only be specified if there is one type
#
# Constraint: fixed.empty() or (type.count()  <= 1)
# ShEx:
#
# NOT { fhir:fixed {fhir:v .} }  OR (   count  ( fhir:type ) { fhir:v MaxInclusive 1 } )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-22
# Human readable:sliceIsConstraining can only appear if slicename is present
#
# Constraint: sliceIsConstraining.exists() implies sliceName.exists()
# ShEx:
#
#{fhir:sliceIsConstraining .  Implies  {fhir:sliceName .}}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: select
# # Constraint UniqueKey:eld-11
# Human readable:Binding can only be present for coded elements, string, and uri if using FHIR-defined types
#
# Constraint: binding.empty() or type.code.empty() or type.code.contains(":") or type.select((code = 'code') or (code = 'Coding') or (code='CodeableConcept') or (code = 'Quantity') or (code = 'string') or (code = 'uri') or (code = 'Duration')).exists()
# ShEx:
#
# NOT { fhir:binding {fhir:v .} }  OR  NOT { fhir:type.code {fhir:v .} }  OR {fhir:type.code { fhir:v [':'] }  OR {fhir:type.  select  (code { fhir:v ['code'] }  OR code { fhir:v ['Coding'] }  OR code { fhir:v ['CodeableConcept'] }  OR code { fhir:v ['Quantity'] }  OR code { fhir:v ['string'] }  OR code { fhir:v ['uri'] }  OR code { fhir:v ['Duration'] } ) .}}
{}

) AND (

# Constraint UniqueKey:eld-8
# Human readable:Pattern and fixed are mutually exclusive

# Constraint: pattern.empty() or fixed.empty()
# ShEx:

 NOT { fhir:pattern {fhir:v .} }  OR  NOT { fhir:fixed {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: where
# # Constraint UniqueKey:eld-25
# Human readable:Order has no meaning (and cannot be asserted to have meaning), so enforcing rules on order is improper
#
# Constraint: orderMeaning.empty() implies slicing.where(rules='openAtEnd' or ordered).exists().not()
# ShEx:
#
# NOT { fhir:orderMeaning {fhir:v .} }   Implies   NOT { fhir:slicing.  where  (rules { fhir:v ['openAtEnd'] }  OR ordered) . }
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-14
# Human readable:Constraints must be unique by key
#
# Constraint: constraint.select(key).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:constraint.  select  (key) )
{}

) AND (

# Constraint UniqueKey:eld-24
# Human readable:pattern[x] should be used rather than fixed[x]

# Constraint: fixed.exists().not()
# ShEx:

 NOT { fhir:fixed . }

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-13
# Human readable:Types must be unique by code
#
# Constraint: type.select(code).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:type.  select  (code) )
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: isDistinct
# Unmapped construct found: select
# # Constraint UniqueKey:eld-27
# Human readable:Mappings SHOULD be unique by key
#
# Constraint: mapping.select(identity).isDistinct()
# ShEx:
#
#   isDistinct  ( fhir:mapping.  select  (identity) )
{}

) AND (

# Constraint UniqueKey:eld-16
# Human readable:sliceName must be composed of proper tokens separated by "/"

# Constraint: sliceName.empty() or sliceName.matches('^[a-zA-Z0-9\\/\\-_\\[\\]\\@]+$')
# ShEx:

 NOT { fhir:sliceName {fhir:v .} }  OR {fhir:sliceName { fhir:v /'^[a-zA-Z0-9\/\-_\[\]\@]+$'/ } }

) AND (

# Constraint UniqueKey:eld-15
# Human readable:default value and meaningWhenMissing are mutually exclusive

# Constraint: defaultValue.empty() or meaningWhenMissing.empty()
# ShEx:

 NOT { fhir:defaultValue {fhir:v .} }  OR  NOT { fhir:meaningWhenMissing {fhir:v .} } 

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-18
# Human readable:Must have a modifier reason if isModifier = true
#
# Constraint: (isModifier.exists() and isModifier) implies isModifierReason.exists()
# ShEx:
#
#({fhir:isModifier . AND { fhir:isModifier }})  Implies  {fhir:isModifierReason .}
{}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-28
# Human readable:Can't have valueAlternatives if mustHaveValue is true
#
# Constraint: mustHaveValue.value implies valueAlternatives.empty()
# ShEx:
#
#{fhir:mustHaveValue.value  Implies   NOT { fhir:valueAlternatives {fhir:v .} } }
{}

) AND (

# Constraint UniqueKey:eld-20
# Human readable:Element names should be simple alphanumerics with a max of 64 characters or code generation tools may be broken

# Constraint: path.matches('^[A-Za-z][A-Za-z0-9]{0,63}(\\.[a-z][A-Za-z0-9]{0,63}(\\[x])?)*$')
# ShEx:

{fhir:path { fhir:v /'^[A-Za-z][A-Za-z0-9]{0,63}(\.[a-z][A-Za-z0-9]{0,63}(\[x])?)*$'/ } }

) AND (

# Constraint UniqueKey:eld-4
# Human readable:Aggregation may only be specified if one of the allowed types for the element is a reference

# Constraint: aggregation.empty() or (code = 'Reference') or (code = 'canonical') or (code = 'CodeableReference')
# ShEx:

 NOT { fhir:aggregation {fhir:v .} }  OR ({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })

) AND (

# Constraint UniqueKey:eld-17
# Human readable:targetProfile is only allowed if the type is Reference or canonical

# Constraint: (code='Reference' or code = 'canonical' or code = 'CodeableReference') or targetProfile.empty()
# ShEx:

(({ fhir:code { fhir:v ['Reference'] }  }) OR ({ fhir:code { fhir:v ['canonical'] }  }) OR ({ fhir:code { fhir:v ['CodeableReference'] }  })) OR  NOT { fhir:targetProfile {fhir:v .} } 

) AND (

# Constraint UniqueKey:eld-21
# Human readable:Constraints should have an expression or else validators will not be able to enforce them

# Constraint: expression.exists()
# ShEx:

{fhir:expression .}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# # Constraint UniqueKey:eld-26
# Human readable:Errors cannot be suppressed
#
# Constraint: (severity = 'error') implies suppress.empty()
# ShEx:
#
#({ fhir:severity { fhir:v ['error'] }  })  Implies   NOT { fhir:suppress {fhir:v .} } 
{}

) AND (

# Constraint UniqueKey:eld-23
# Human readable:binding SHALL have either description or valueSet

# Constraint: description.exists() or valueSet.exists()
# ShEx:

{fhir:description . OR {fhir:valueSet .}}

) AND (


# This constraint does not have mapping to a ShEx construct yet.
# Unmapped construct found: Implies
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# Unmapped construct found: startsWith
# # Constraint UniqueKey:eld-12
# Human readable:ValueSet SHALL start with http:// or https:// or urn: or #
#
# Constraint: valueSet.exists() implies (valueSet.startsWith('http:') or valueSet.startsWith('https') or valueSet.startsWith('urn:') or valueSet.startsWith('#'))
# ShEx:
#
#{fhir:valueSet .  Implies  ({fhir:valueSet.  startsWith  ('http:') OR {fhir:valueSet.  startsWith  ('https') OR {fhir:valueSet.  startsWith  ('urn:') OR {fhir:valueSet.  startsWith  ('#')}}}})}
{}

)
 

# Element values that are used to distinguish the slices
<ElementDefinition.slicing.discriminator> EXTENDS @<Element> CLOSED {   
    fhir:type @<code> AND
    	{fhir:v @fhirvs:discriminator-type};  # value | exists | type | profile | 
                                            # position 
    fhir:path @<string>;                    # Path to element value
}  

# This element is sliced - slices follow
<ElementDefinition.slicing> EXTENDS @<Element> CLOSED {   
    fhir:discriminator @<OneOrMore_Element>?;  # Element values that are used to 
                                            # distinguish the slices 
    fhir:description @<string>?;            # Text description of how slicing 
                                            # works (or not) 
    fhir:ordered @<boolean>?;               # If elements must be in same order 
                                            # as slices 
    fhir:rules @<code> AND
    	{fhir:v @fhirvs:resource-slicing-rules};  # closed | open | openAtEnd
}  

# Example value (as defined for type)
<ElementDefinition.example> EXTENDS @<Element> CLOSED {   
    fhir:label @<string>;                   # Describes the purpose of this 
                                            # example 
    fhir:value @<base64Binary>  OR 
    			@<boolean>  OR 
    			@<canonical>  OR 
    			@<code>  OR 
    			@<date>  OR 
    			@<dateTime>  OR 
    			@<decimal>  OR 
    			@<id>  OR 
    			@<instant>  OR 
    			@<integer>  OR 
    			@<integer64>  OR 
    			@<markdown>  OR 
    			@<oid>  OR 
    			@<positiveInt>  OR 
    			@<string>  OR 
    			@<time>  OR 
    			@<unsignedInt>  OR 
    			@<uri>  OR 
    			@<url>  OR 
    			@<uuid>  OR 
    			@<Address>  OR 
    			@<Age>  OR 
    			@<Annotation>  OR 
    			@<Attachment>  OR 
    			@<CodeableConcept>  OR 
    			@<CodeableReference>  OR 
    			@<Coding>  OR 
    			@<ContactPoint>  OR 
    			@<Count>  OR 
    			@<Distance>  OR 
    			@<Duration>  OR 
    			@<HumanName>  OR 
    			@<Identifier>  OR 
    			@<Money>  OR 
    			@<Period>  OR 
    			@<Quantity>  OR 
    			@<Range>  OR 
    			@<Ratio>  OR 
    			@<RatioRange>  OR 
    			@<Reference>  OR 
    			@<SampledData>  OR 
    			@<Signature>  OR 
    			@<Timing>  OR 
    			@<ContactDetail>  OR 
    			@<DataRequirement>  OR 
    			@<Expression>  OR 
    			@<ParameterDefinition>  OR 
    			@<RelatedArtifact>  OR 
    			@<TriggerDefinition>  OR 
    			@<UsageContext>  OR 
    			@<Availability>  OR 
    			@<ExtendedContactDetail>  OR 
    			@<Dosage>  OR 
    			@<Meta>  ;  # Value of Example (one of allowed 
                                            # types) 
}  

# Map element to another set of definitions
<ElementDefinition.mapping> EXTENDS @<Element> CLOSED {   
    fhir:identity @<id>;                    # Reference to mapping declaration
    fhir:language @<code> AND
    	{fhir:v @fhirvs:mimetypes}?;  # Computable language of mapping
    fhir:map @<string>;                     # Details of the mapping
    fhir:comment @<markdown>?;              # Comments about the mapping or its 
                                            # use 
}  

# Additional Bindings - more rules about the binding
<ElementDefinition.binding.additional> EXTENDS @<Element> CLOSED {   
    fhir:purpose @<code> AND
    	{fhir:v @fhirvs:additional-binding-purpose};  # maximum | minimum | required | 
                                            # extensible | candidate | current | 
                                            # preferred | ui | starter | 
                                            # component 
    fhir:valueSet @<canonical>;             # The value set for the additional 
                                            # binding 
    fhir:documentation @<markdown>?;        # Documentation of the purpose of 
                                            # use of the binding 
    fhir:shortDoco @<string>?;              # Concise documentation - for 
                                            # summary tables 
    fhir:usage @<OneOrMore_UsageContext>?;  # Qualifies the usage - 
                                            # jurisdiction, gender, workflow 
                                            # status etc 
    fhir:any @<boolean>?;                   # Whether binding can applies to all 
                                            # repeats, or just one 
}  

#---------------------- Cardinality Types (OneOrMore) -------------------

<OneOrMore_code> CLOSED {
    rdf:first @<code>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_code> 
}

<OneOrMore_Coding> CLOSED {
    rdf:first @<Coding>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_Coding> 
}

<OneOrMore_string> CLOSED {
    rdf:first @<string>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_string> 
}

<OneOrMore_Element> CLOSED {
    rdf:first @<Element>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_Element> 
}

<OneOrMore_id> CLOSED {
    rdf:first @<id>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_id> 
}

<OneOrMore_canonical> CLOSED {
    rdf:first @<canonical>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_canonical> 
}

<OneOrMore_UsageContext> CLOSED {
    rdf:first @<UsageContext>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_UsageContext> 
}

<OneOrMore_uri> CLOSED {
    rdf:first @<uri>  ;
    rdf:rest [rdf:nil] OR @<OneOrMore_uri> 
}

#---------------------- Value Sets ------------------------

# Additional Binding Purpose
fhirvs:additional-binding-purpose ["maximum" "minimum" "required" "extensible" "candidate" "current" "preferred" "ui" "starter" "component"]

# Indication of the degree of conformance expectations associated with a binding.
fhirvs:binding-strength ["required" "extensible" "preferred" "example"]

# How slices are interpreted when evaluating an instance.
fhirvs:resource-slicing-rules ["closed" "open" "openAtEnd"]

# How resource references can be aggregated.
fhirvs:resource-aggregation-mode ["contained" "referenced" "bundled"]

# How an element value is interpreted when discrimination is evaluated.
fhirvs:discriminator-type ["value" "exists" "pattern" "type" "profile" "position"]

# SHALL applications comply with this constraint?
fhirvs:constraint-severity ["error" "warning"]

# This value set includes all possible codes from BCP-13 (http://tools.ietf.org/html/bcp13)
fhirvs:mimetypes xsd:string #EXTERNAL

# How a property is represented when serialized.
fhirvs:property-representation ["xmlAttr" "xmlText" "typeAttr" "cdaText" "xhtml"]

# Whether a reference needs to be version specific or version independent, or whether either can be used.
fhirvs:reference-version-rules ["either" "independent" "specific"]

